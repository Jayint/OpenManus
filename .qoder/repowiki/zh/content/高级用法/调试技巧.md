# 调试技巧

<cite>
**本文档中引用的文件**   
- [logger.py](file://app/logger.py)
- [toolcall.py](file://app/agent/toolcall.py)
- [schema.py](file://app/schema.py)
- [base.py](file://app/agent/base.py)
- [sb_vision_tool.py](file://app/tool/sandbox/sb_vision_tool.py)
- [llm.py](file://app/llm.py)
</cite>

## 目录
1. [日志系统配置](#日志系统配置)
2. [日志标记与执行流程追踪](#日志标记与执行流程追踪)
3. [消息序列分析](#消息序列分析)
4. [调用链上下文追踪](#调用链上下文追踪)
5. [典型问题诊断模式](#典型问题诊断模式)

## 日志系统配置

本项目采用 `loguru` 作为核心日志库，结合 `structlog` 提供结构化日志支持。日志级别和输出策略通过 `define_log_level` 函数进行配置，该函数允许独立设置控制台输出和日志文件的级别。

`define_log_level` 函数接受三个参数：
- `print_level`：控制台输出的日志级别，默认为 "INFO"。
- `logfile_level`：日志文件记录的级别，默认为 "DEBUG"，确保所有详细信息被持久化。
- `name`：可选的日志文件前缀名，便于区分不同运行实例。

该函数首先移除所有现有的日志处理器，然后添加两个新的处理器：一个将指定级别的日志输出到标准错误流（`sys.stderr`），另一个将更详细的日志（`DEBUG` 级别及以上）写入位于 `PROJECT_ROOT/logs/` 目录下的时间戳命名文件中。这种分离策略使得开发者可以在终端快速查看关键信息，同时保留完整的调试记录以供后续分析。

**Section sources**
- [logger.py](file://app/logger.py#L11-L25)

## 日志标记与执行流程追踪

系统使用特定的 Emoji 标记来快速识别日志中的关键事件，极大地提升了日志的可读性和问题定位效率。

- **✨ (思维链)**：标记代理（Agent）的核心思考过程。日志格式为 `✨ {代理名称}'s thoughts: {内容}`，直接输出 LLM 生成的推理和决策内容，是理解代理行为逻辑的首要入口。
- **🛠️ (工具选择)**：标识代理选择的工具。日志会显示代理决定使用的工具数量、具体工具名称（`🧰 Tools being prepared`）以及传递给第一个工具的参数（`🔧 Tool arguments`），用于验证工具选择和参数构造是否正确。
- **🎯 (执行结果)**：报告工具执行的最终结果。格式为 `🎯 Tool '{工具名}' completed its mission! Result: {结果}`，清晰地展示了每个工具调用的输出，是验证功能正确性的关键。
- **🚨 (错误)**：标记严重的错误和异常，通常伴随完整的堆栈跟踪（`logger.exception`），用于诊断崩溃和未处理的异常。
- **🔧 (工具激活)**：在执行工具前输出 `🔧 Activating tool: '{工具名}'...`，用于确认工具调用流程已进入执行阶段。

这些标记使得开发者可以通过简单的文本搜索（如 `grep "✨"`）快速过滤出特定类型的日志，无需阅读大量无关信息。

**Section sources**
- [toolcall.py](file://app/agent/toolcall.py#L79-L114)

## 消息序列分析

代理的执行流程完全由其内存（`memory`）中的消息序列驱动。`memory.messages` 是一个 `Message` 对象列表，记录了从用户请求到最终响应的完整对话历史。

每个 `Message` 对象包含以下关键字段：
- `role`：消息角色（`user`, `system`, `assistant`, `tool`），用于区分消息来源。
- `content`：消息的文本内容。
- `tool_calls`：当 `role` 为 `assistant` 时，此字段包含待执行的工具调用列表，是分析代理决策的核心。
- `tool_call_id` 和 `name`：当 `role` 为 `tool` 时，这两个字段将工具的响应结果与原始的 `tool_calls` 关联起来。
- `base64_image`：可选字段，用于传递图像数据的 Base64 编码字符串。

通过分析 `memory.messages` 的序列，可以清晰地追踪整个执行流程：
1.  用户输入（`role: user`）触发代理。
2.  代理生成包含 `tool_calls` 的响应（`role: assistant`）。
3.  系统执行工具，并将结果作为新消息添加（`role: tool`），其 `tool_call_id` 与步骤2中的调用ID匹配。
4.  代理根据工具结果生成下一步响应，循环往复。

**Section sources**
- [schema.py](file://app/schema.py#L53-L155)
- [base.py](file://app/agent/base.py#L73-L113)

## 调用链上下文追踪

项目同时使用 `structlog` 进行高级日志记录。`structlog` 的配置会根据环境变量 `ENV_MODE` 动态调整输出格式：在 `LOCAL` 模式下使用彩色控制台渲染器，便于本地开发调试；在其他模式下使用 JSON 格式，便于日志聚合和分析。

`structlog` 的核心优势在于其上下文变量（`contextvars`）功能。通过 `structlog.contextvars.merge_contextvars` 处理器，可以在日志调用前使用 `structlog.contextvars.bind_contextvars(key=value)` 绑定任意上下文信息（如 `request_id`, `user_id`）。这些上下文信息会自动附加到后续的所有日志条目中，直到被清除。

这种机制实现了跨函数和模块的调用链追踪。例如，可以在请求入口处绑定一个唯一的 `request_id`，那么该请求生命周期内产生的所有日志都将包含此ID，使得在海量日志中通过 `request_id` 过滤出单个请求的完整执行轨迹成为可能，极大地简化了分布式问题的排查。

**Section sources**
- [utils/logger.py](file://app/utils/logger.py#L0-L31)

## 典型问题诊断模式

### 工具未注册
**现象**：日志中出现 `Error: Unknown tool '{name}'`。
**诊断**：此错误由 `ToolCallAgent.execute_tool` 方法抛出。检查 `name` 是否拼写正确，并确认该工具实例已正确添加到代理的 `available_tools` 工具集合中。

### 参数解析失败
**现象**：日志中出现 `📝 Oops! The arguments for '{name}' don't make sense - invalid JSON, arguments:{command.function.arguments}`。
**诊断**：此警告表明 LLM 生成的工具参数不是有效的 JSON 格式。检查 `arguments` 字段的原始字符串，分析是 LLM 的提示词（prompt）设计问题，还是工具的参数定义（`parameters` schema）不够清晰导致 LLM 无法正确构造。

### 图像传递问题
**现象**：需要图像输入的工具（如视觉分析）未能接收到图像。
**诊断**：
1.  检查用户消息或上游工具的响应中是否设置了 `base64_image` 字段。
2.  在 `llm.py` 的 `ask_tool` 方法中，确认 `supports_images` 条件为真，且 `base64_image` 被正确地转换为符合模型要求的 `image_url` 格式并添加到消息内容中。
3.  在 `ToolCallAgent.act` 方法中，检查 `_current_base64_image` 是否被正确设置。该字段由 `execute_tool` 方法在执行返回 `ToolResult` 且包含 `base64_image` 时设置，并在创建 `tool_msg` 时传递。

**Section sources**
- [toolcall.py](file://app/agent/toolcall.py#L144-L183)
- [llm.py](file://app/llm.py#L303-L331)
- [sb_vision_tool.py](file://app/tool/sandbox/sb_vision_tool.py#L158-L177)