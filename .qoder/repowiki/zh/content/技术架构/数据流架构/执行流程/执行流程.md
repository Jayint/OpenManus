# 执行流程

<cite>
**本文档引用的文件**   
- [base.py](file://app/agent/base.py)
- [llm.py](file://app/llm.py)
- [tool_collection.py](file://app/tool/tool_collection.py)
</cite>

## 目录
1. [简介](#简介)
2. [核心执行机制](#核心执行机制)
3. [状态上下文管理](#状态上下文管理)
4. [循环状态检测与处理](#循环状态检测与处理)
5. [工具调用处理机制](#工具调用处理机制)
6. [工具协调与执行](#工具协调与执行)
7. [执行流程状态转换](#执行流程状态转换)
8. [工具选择决策](#工具选择决策)

## 简介
OpenManus代理系统采用基于步骤的执行机制，通过循环执行`step`方法来完成复杂任务。该系统集成了状态管理、循环检测、工具调用和决策机制，确保代理能够高效、可靠地执行任务。本文档详细描述了代理的执行流程，包括`BaseAgent`的`run`方法如何在状态上下文管理器中循环执行`step`方法，以及如何通过`is_stuck`和`handle_stuck_state`方法检测和处理循环状态。同时，文档还阐述了LLM模块的`ask_tool`方法如何处理工具调用请求，以及`ToolCollection`如何协调可用工具的执行。

## 核心执行机制

`BaseAgent`类的`run`方法是代理执行的核心，它实现了基于步骤的异步执行循环。该方法首先检查代理的当前状态，确保代理处于空闲状态（IDLE）才能开始执行。如果提供了初始用户请求，该请求将被添加到代理的记忆中。

执行循环在`state_context`上下文管理器中运行，代理状态被设置为运行中（RUNNING）。循环持续执行，直到达到最大步骤数或代理状态变为完成（FINISHED）。在每个步骤中，代理调用`step`方法执行单个步骤，并检查是否陷入循环状态。如果检测到循环状态，将调用`handle_stuck_state`方法进行处理。

```mermaid
flowchart TD
Start([开始]) --> CheckState["检查代理状态"]
CheckState --> |状态为IDLE| Initialize["初始化执行"]
Initialize --> EnterContext["进入state_context"]
EnterContext --> Loop["执行循环"]
Loop --> |当前步骤 < 最大步骤 且 状态 ≠ FINISHED| IncrementStep["步骤计数+1"]
IncrementStep --> ExecuteStep["执行step方法"]
ExecuteStep --> CheckStuck["检查是否陷入循环"]
CheckStuck --> |是| HandleStuck["处理循环状态"]
HandleStuck --> AppendResult["添加步骤结果"]
CheckStuck --> |否| AppendResult
AppendResult --> Loop
Loop --> |循环结束| Cleanup["清理资源"]
Cleanup --> ReturnResult["返回执行结果"]
ReturnResult --> End([结束])
CheckState --> |状态不为IDLE| Error["抛出运行时错误"]
Error --> End
```

**Diagram sources**
- [base.py](file://app/agent/base.py#L115-L153)

**Section sources**
- [base.py](file://app/agent/base.py#L115-L153)

## 状态上下文管理

`state_context`是一个异步上下文管理器，用于安全地管理代理的状态转换。当进入上下文时，代理状态被设置为新的状态，同时保存当前状态作为前一个状态。在上下文中执行代码时，如果发生异常，代理状态将被设置为错误（ERROR），并重新抛出异常。无论是否发生异常，退出上下文时，代理状态都将恢复为前一个状态。

这种机制确保了状态转换的安全性，即使在执行过程中发生错误，代理状态也能正确恢复，避免了状态不一致的问题。

```mermaid
stateDiagram-v2
[*] --> IDLE
IDLE --> RUNNING : run()调用
RUNNING --> ERROR : 发生异常
ERROR --> IDLE : 上下文退出
RUNNING --> IDLE : 循环结束
IDLE --> ERROR : 状态检查失败
ERROR --> [*]
IDLE --> [*]
```

**Diagram sources**
- [base.py](file://app/agent/base.py#L58-L81)

**Section sources**
- [base.py](file://app/agent/base.py#L58-L81)

## 循环状态检测与处理

`is_stuck`方法用于检测代理是否陷入循环状态。该方法通过检查记忆中的消息来判断是否存在重复的响应。如果最后一条消息的内容与之前的消息内容相同，且重复次数达到或超过`duplicate_threshold`（默认为2），则认为代理陷入了循环状态。

`handle_stuck_state`方法用于处理检测到的循环状态。该方法通过向`next_step_prompt`添加一个提示，建议代理考虑新的策略，避免重复无效的路径。这有助于代理跳出循环，尝试不同的解决方案。

```mermaid
flowchart TD
Start([开始]) --> CheckMessageCount["检查消息数量"]
CheckMessageCount --> |消息数量 < 2| ReturnFalse["返回false"]
CheckMessageCount --> |消息数量 ≥ 2| GetLastMessage["获取最后一条消息"]
GetLastMessage --> CheckContent["检查消息内容"]
CheckContent --> |内容为空| ReturnFalse
CheckContent --> |内容不为空| CountDuplicates["计算重复内容"]
CountDuplicates --> CheckThreshold["检查重复次数 ≥ 阈值?"]
CheckThreshold --> |是| ReturnTrue["返回true"]
CheckThreshold --> |否| ReturnFalse
ReturnTrue --> End([结束])
ReturnFalse --> End
```

**Diagram sources**
- [base.py](file://app/agent/base.py#L169-L185)
- [base.py](file://app/agent/base.py#L162-L167)

**Section sources**
- [base.py](file://app/agent/base.py#L169-L185)
- [base.py](file://app/agent/base.py#L162-L167)

## 工具调用处理机制

`LLM`类的`ask_tool`方法用于处理工具调用请求。该方法首先验证`tool_choice`参数，然后检查模型是否支持图像。接着，消息被格式化为LLM可以理解的格式，并计算输入令牌数。如果存在工具，还将计算工具描述的令牌数。

在检查令牌限制后，方法设置完成请求的参数，包括模型、消息、工具、工具选择策略和超时时间。请求以非流式方式发送，以确保能够正确处理工具调用。如果响应有效，将更新令牌计数并返回模型的响应。

```mermaid
flowchart TD
Start([开始]) --> ValidateToolChoice["验证tool_choice"]
ValidateToolChoice --> CheckImages["检查模型是否支持图像"]
CheckImages --> FormatMessages["格式化消息"]
FormatMessages --> CalculateTokens["计算输入令牌数"]
CalculateTokens --> CheckLimit["检查令牌限制"]
CheckLimit --> |超出限制| RaiseError["抛出TokenLimitExceeded"]
CheckLimit --> |未超出限制| SetParams["设置请求参数"]
SetParams --> SendRequest["发送非流式请求"]
SendRequest --> CheckResponse["检查响应有效性"]
CheckResponse --> |响应无效| ReturnNone["返回None"]
CheckResponse --> |响应有效| UpdateTokens["更新令牌计数"]
UpdateTokens --> ReturnResponse["返回响应"]
ReturnResponse --> End([结束])
RaiseError --> End
ReturnNone --> End
```

**Diagram sources**
- [llm.py](file://app/llm.py#L643-L765)

**Section sources**
- [llm.py](file://app/llm.py#L643-L765)

## 工具协调与执行

`ToolCollection`类用于管理一组工具。它提供了一个工具映射（`tool_map`），通过工具名称快速查找工具。`execute`方法根据名称执行单个工具，如果工具不存在，则返回工具失败结果。`execute_all`方法按顺序执行所有工具。

`add_tool`和`add_tools`方法允许向集合中添加工具。如果工具名称已存在，将跳过该工具并记录警告。`to_params`方法将所有工具转换为参数格式，以便传递给LLM。

```mermaid
classDiagram
class ToolCollection {
+tools : Tuple[BaseTool]
+tool_map : Dict[str, BaseTool]
+__init__(*tools : BaseTool)
+__iter__()
+to_params() List[Dict[str, Any]]
+execute(name : str, tool_input : Dict[str, Any]) ToolResult
+execute_all() List[ToolResult]
+get_tool(name : str) BaseTool
+add_tool(tool : BaseTool) ToolCollection
+add_tools(*tools : BaseTool) ToolCollection
}
class BaseTool {
+name : str
+description : str
+parameters : Optional[dict]
+__call__(**kwargs) Any
+execute(**kwargs) Any
+to_param() Dict
}
class ToolResult {
+output : Any
+error : Optional[str]
+base64_image : Optional[str]
+system : Optional[str]
+__bool__()
+__add__(other : ToolResult) ToolResult
+__str__()
+replace(**kwargs) ToolResult
}
ToolCollection --> BaseTool : "包含"
ToolCollection --> ToolResult : "返回"
```

**Diagram sources**
- [tool_collection.py](file://app/tool/tool_collection.py#L8-L70)

**Section sources**
- [tool_collection.py](file://app/tool/tool_collection.py#L8-L70)

## 执行流程状态转换

代理的执行流程涉及多个状态的转换。从空闲状态开始，代理进入运行状态，执行步骤循环。在每个步骤中，代理调用`step`方法，该方法的具体实现由子类定义。如果代理陷入循环状态，将触发循环处理机制。当达到最大步骤数或代理状态变为完成时，循环结束，代理返回空闲状态。

```mermaid
stateDiagram-v2
[*] --> IDLE
IDLE --> RUNNING : run()调用
RUNNING --> EXECUTING : 进入执行循环
EXECUTING --> THINKING : ReActAgent的think()
THINKING --> ACTING : should_act为真
THINKING --> EXECUTING : should_act为假
ACTING --> EXECUTING : act()完成
EXECUTING --> STUCK : is_stuck()为真
STUCK --> EXECUTING : handle_stuck_state()后继续
EXECUTING --> FINISHED : 状态为FINISHED
EXECUTING --> IDLE : 达到最大步骤数
FINISHED --> IDLE : 循环结束
IDLE --> [*]
```

**Diagram sources**
- [base.py](file://app/agent/base.py#L115-L153)
- [react.py](file://app/agent/react.py#L32-L37)

**Section sources**
- [base.py](file://app/agent/base.py#L115-L153)
- [react.py](file://app/agent/react.py#L32-L37)

## 工具选择决策

工具选择决策树描述了代理如何根据任务需求选择合适的工具。首先，代理分析当前任务，确定需要执行的操作类型。然后，根据操作类型从可用工具中选择最合适的工具。如果存在多个候选工具，代理将根据工具的描述和参数进行选择。

```mermaid
flowchart TD
Start([开始]) --> AnalyzeTask["分析当前任务"]
AnalyzeTask --> DetermineAction["确定操作类型"]
DetermineAction --> SelectTool["选择最合适的工具"]
SelectTool --> CheckAvailability["检查工具可用性"]
CheckAvailability --> |工具可用| ExecuteTool["执行工具"]
CheckAvailability --> |工具不可用| HandleError["处理错误"]
ExecuteTool --> ProcessResult["处理工具结果"]
ProcessResult --> Continue["继续执行"]
HandleError --> Continue
Continue --> End([结束])
```

**Diagram sources**
- [tool_collection.py](file://app/tool/tool_collection.py#L24-L34)
- [llm.py](file://app/llm.py#L643-L765)

**Section sources**
- [tool_collection.py](file://app/tool/tool_collection.py#L24-L34)
- [llm.py](file://app/llm.py#L643-L765)