# 沙箱执行架构

<cite>
**本文档引用的文件**   
- [manager.py](file://app/sandbox/core/manager.py)
- [sandbox.py](file://app/sandbox/core/sandbox.py)
- [terminal.py](file://app/sandbox/core/terminal.py)
- [client.py](file://app/sandbox/client.py)
- [config.py](file://app/config.py)
- [sandbox_agent.py](file://app/agent/sandbox_agent.py)
</cite>

## 目录
1. [简介](#简介)
2. [沙箱管理器生命周期管理](#沙箱管理器生命周期管理)
3. [终端接口抽象与实现](#终端接口抽象与实现)
4. [安全控制机制](#安全控制机制)
5. [通信协议与数据交换](#通信协议与数据交换)
6. [沙箱架构部署图](#沙箱架构部署图)
7. [安全隔离层次图](#安全隔离层次图)
8. [性能优化与故障排查](#性能优化与故障排查)

## 简介
OpenManus沙箱执行架构基于Docker容器技术，为代码执行提供安全隔离的运行环境。该架构通过SandboxManager统一管理沙箱生命周期，利用Docker容器实现资源隔离和限制，并通过Terminal接口与容器进行交互。系统支持文件系统挂载、网络隔离和资源限制等安全控制机制，确保沙箱环境的安全性和稳定性。

## 沙箱管理器生命周期管理

SandboxManager是沙箱生命周期管理的核心组件，负责沙箱的创建、运行和销毁。它通过Docker API与容器引擎交互，管理多个DockerSandbox实例的生命周期。

### 沙箱创建流程
沙箱创建流程由`create_sandbox`方法实现，主要步骤包括：
1. 检查最大沙箱数量限制
2. 确保Docker镜像可用
3. 创建DockerSandbox实例
4. 启动容器并初始化终端
5. 注册沙箱实例到管理器

```mermaid
sequenceDiagram
participant Client as "客户端"
participant Manager as "SandboxManager"
participant Docker as "Docker引擎"
Client->>Manager : create_sandbox()
Manager->>Manager : 检查沙箱数量限制
Manager->>Manager : 确保Docker镜像可用
Manager->>Docker : 创建容器
Docker-->>Manager : 容器创建成功
Manager->>Manager : 初始化终端会话
Manager->>Manager : 注册沙箱实例
Manager-->>Client : 返回沙箱ID
```

**Diagram sources**
- [manager.py](file://app/sandbox/core/manager.py#L113-L156)
- [sandbox.py](file://app/sandbox/core/sandbox.py#L88-L130)

### 沙箱销毁机制
沙箱销毁通过`delete_sandbox`方法实现，包含安全删除和自动清理两种机制：

1. **主动销毁**：通过`delete_sandbox`方法主动删除指定沙箱
2. **自动清理**：通过`_cleanup_idle_sandboxes`方法定期清理空闲沙箱
3. **全局清理**：通过`cleanup`方法在系统关闭时清理所有沙箱资源

```mermaid
flowchart TD
Start([开始销毁]) --> CheckActive["检查是否有活跃操作"]
CheckActive --> |有活跃操作| Wait["等待操作完成"]
Wait --> CheckActive
CheckActive --> |无活跃操作| StopContainer["停止容器"]
StopContainer --> RemoveContainer["删除容器"]
RemoveContainer --> RemoveRecord["从管理器移除记录"]
RemoveRecord --> End([销毁完成])
```

**Diagram sources**
- [manager.py](file://app/sandbox/core/manager.py#L243-L275)
- [manager.py](file://app/sandbox/core/manager.py#L186-L203)

**Section sources**
- [manager.py](file://app/sandbox/core/manager.py#L243-L275)
- [manager.py](file://app/sandbox/core/manager.py#L186-L203)

## 终端接口抽象与实现

沙箱架构采用分层设计，通过Terminal接口实现与容器的交互，提供了清晰的抽象与具体实现分离。

### 接口抽象设计
系统定义了`BaseSandboxClient`抽象基类，规范了沙箱客户端的基本操作接口：

```mermaid
classDiagram
class BaseSandboxClient {
<<abstract>>
+create(config, volume_bindings)
+run_command(command, timeout)
+copy_from(container_path, local_path)
+copy_to(local_path, container_path)
+read_file(path)
+write_file(path, content)
+cleanup()
}
class LocalSandboxClient {
-sandbox : DockerSandbox
+create(config, volume_bindings)
+run_command(command, timeout)
+copy_from(container_path, local_path)
+copy_to(local_path, container_path)
+read_file(path)
+write_file(path, content)
+cleanup()
}
BaseSandboxClient <|-- LocalSandboxClient
```

**Diagram sources**
- [client.py](file://app/sandbox/client.py#L52-L101)

### Docker终端实现
`AsyncDockerizedTerminal`是Docker终端的具体实现，通过`DockerSession`与容器进行交互：

```mermaid
classDiagram
class AsyncDockerizedTerminal {
-client : docker.client
-container : Container
-working_dir : str
-env_vars : Dict[str,str]
-default_timeout : int
-session : DockerSession
+init()
+run_command(cmd, timeout)
+close()
+__aenter__()
+__aexit__()
}
class DockerSession {
-api : APIClient
-container_id : str
-exec_id : str
-socket : socket
+create(working_dir, env_vars)
+close()
+execute(command, timeout)
+_read_until_prompt()
+_sanitize_command(command)
}
AsyncDockerizedTerminal --> DockerSession : "使用"
```

**Diagram sources**
- [terminal.py](file://app/sandbox/core/terminal.py#L100-L346)

**Section sources**
- [terminal.py](file://app/sandbox/core/terminal.py#L100-L346)

## 安全控制机制

沙箱架构通过多层次的安全控制机制确保执行环境的安全性。

### 文件系统挂载
文件系统挂载通过`_prepare_volume_bindings`方法实现，将主机临时目录挂载到容器工作目录：

```python
def _prepare_volume_bindings(self) -> Dict[str, Dict[str, str]]:
    bindings = {}
    # 创建并添加工作目录映射
    work_dir = self._ensure_host_dir(self.config.work_dir)
    bindings[work_dir] = {"bind": self.config.work_dir, "mode": "rw"}
    # 添加自定义卷绑定
    for host_path, container_path in self.volume_bindings.items():
        bindings[host_path] = {"bind": container_path, "mode": "rw"}
    return bindings
```

**Section sources**
- [sandbox.py](file://app/sandbox/core/sandbox.py#L198-L212)

### 网络隔离
网络隔离通过Docker的网络模式配置实现，在容器创建时根据配置决定是否启用网络：

```mermaid
flowchart TD
Start([创建容器]) --> CheckNetwork["检查网络配置"]
CheckNetwork --> |网络禁用| SetNetworkMode["设置网络模式为none"]
CheckNetwork --> |网络启用| SetNetworkModeBridge["设置网络模式为bridge"]
SetNetworkMode --> CreateContainer["创建容器"]
SetNetworkModeBridge --> CreateContainer
CreateContainer --> End([容器创建完成])
```

**Section sources**
- [sandbox.py](file://app/sandbox/core/sandbox.py#L98-L105)

### 资源限制
资源限制通过Docker的资源控制参数实现，包括内存和CPU限制：

```mermaid
erDiagram
SANDBOX_CONFIG {
string image
string work_dir
string memory_limit
float cpu_limit
int timeout
bool network_enabled
}
CONTAINER_RESOURCES {
string mem_limit
int cpu_period
int cpu_quota
string network_mode
}
SANDBOX_CONFIG ||--o{ CONTAINER_RESOURCES : "映射配置"
```

**Section sources**
- [sandbox.py](file://app/sandbox/core/sandbox.py#L95-L98)

## 通信协议与数据交换

沙箱与主进程之间的通信通过异步API实现，支持命令执行和文件操作。

### 命令执行协议
命令执行通过终端会话实现，包含命令发送、输出读取和超时控制：

```mermaid
sequenceDiagram
participant Main as "主进程"
participant Terminal as "终端"
participant Container as "容器"
Main->>Terminal : run_command("ls -l")
Terminal->>Container : 创建exec会话
Container-->>Terminal : 返回socket
Terminal->>Container : 发送命令
loop 读取输出
Container->>Terminal : 发送输出数据
Terminal->>Terminal : 缓冲数据
Terminal->>Terminal : 检查是否到达提示符
end
Terminal-->>Main : 返回命令输出
```

**Diagram sources**
- [terminal.py](file://app/sandbox/core/terminal.py#L200-L250)

### 文件数据交换
文件数据交换通过Docker的存档功能实现，使用tar格式在主机和容器之间传输文件：

```mermaid
flowchart LR
A[主机文件] --> B["_create_tar_stream()"]
B --> C[tar流]
C --> D["container.put_archive()"]
D --> E[容器内文件]
E --> F["container.get_archive()"]
F --> G[tar流]
G --> H["_read_from_tar()"]
H --> I[主机文件]
```

**Diagram sources**
- [sandbox.py](file://app/sandbox/core/sandbox.py#L370-L420)

**Section sources**
- [sandbox.py](file://app/sandbox/core/sandbox.py#L370-L420)

## 沙箱架构部署图

```mermaid
graph TD
subgraph "应用层"
Agent[SandboxAgent]
Tools[工具集]
end
subgraph "沙箱管理层"
Manager[SandboxManager]
Client[LocalSandboxClient]
end
subgraph "沙箱核心层"
Sandbox[DockerSandbox]
Terminal[AsyncDockerizedTerminal]
end
subgraph "Docker引擎"
Docker[Docker Daemon]
Container[Docker容器]
end
Agent --> Manager
Manager --> Client
Client --> Sandbox
Sandbox --> Terminal
Terminal --> Docker
Docker --> Container
style Agent fill:#f9f,stroke:#333
style Tools fill:#f9f,stroke:#333
style Manager fill:#bbf,stroke:#333
style Client fill:#bbf,stroke:#333
style Sandbox fill:#9f9,stroke:#333
style Terminal fill:#9f9,stroke:#333
style Docker fill:#f96,stroke:#333
style Container fill:#f96,stroke:#333
```

**Diagram sources**
- [sandbox_agent.py](file://app/agent/sandbox_agent.py#L71-L106)
- [manager.py](file://app/sandbox/core/manager.py#L13-L312)
- [sandbox.py](file://app/sandbox/core/sandbox.py#L13-L462)
- [terminal.py](file://app/sandbox/core/terminal.py#L1-L346)

## 安全隔离层次图

```mermaid
graph TD
A[应用代码] --> B[工具层]
B --> C[沙箱客户端]
C --> D[沙箱实例]
D --> E[Docker容器]
E --> F[主机系统]
subgraph "隔离边界"
B1["工具层隔离"]
C1["进程隔离"]
D1["容器隔离"]
E1["内核隔离"]
end
style A fill:#f96,stroke:#333,color:#fff
style B fill:#f96,stroke:#333,color:#fff
style C fill:#f96,stroke:#333,color:#fff
style D fill:#f96,stroke:#333,color:#fff
style E fill:#f96,stroke:#333,color:#fff
style F fill:#f96,stroke:#333,color:#fff
style B1 fill:#9f9,stroke:#333
style C1 fill:#9f9,stroke:#333
style D1 fill:#9f9,stroke:#333
style E1 fill:#9f9,stroke:#333
```

**Diagram sources**
- [sandbox.py](file://app/sandbox/core/sandbox.py#L13-L462)
- [manager.py](file://app/sandbox/core/manager.py#L13-L312)

## 性能优化与故障排查

### 性能优化建议
1. **连接池优化**：复用Docker客户端连接，减少连接创建开销
2. **批量操作**：合并多个文件操作为单个tar包传输
3. **资源预分配**：预创建常用沙箱实例，减少启动延迟
4. **缓存机制**：缓存常用Docker镜像，避免重复拉取

### 故障排查指南
1. **沙箱创建失败**：
   - 检查Docker服务是否正常运行
   - 验证Docker镜像是否可访问
   - 检查系统资源是否充足

2. **命令执行超时**：
   - 检查命令是否陷入死循环
   - 增加`timeout`配置值
   - 优化命令执行逻辑

3. **文件操作失败**：
   - 验证文件路径是否正确
   - 检查目录权限
   - 确认容器是否正常运行

4. **网络连接问题**：
   - 检查网络配置
   - 验证防火墙设置
   - 确认DNS解析正常

**Section sources**
- [manager.py](file://app/sandbox/core/manager.py#L64-L85)
- [sandbox.py](file://app/sandbox/core/sandbox.py#L174-L216)
- [terminal.py](file://app/sandbox/core/terminal.py#L200-L250)