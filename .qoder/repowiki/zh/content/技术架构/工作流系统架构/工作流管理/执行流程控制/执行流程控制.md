# 执行流程控制

<cite>
**本文档引用的文件**   
- [planning.py](file://app/flow/planning.py)
- [base.py](file://app/flow/base.py)
- [tool_collection.py](file://app/tool/tool_collection.py)
- [planning.py](file://app/tool/planning.py)
- [base.py](file://app/tool/base.py)
</cite>

## 目录
1. [执行主循环](#执行主循环)
2. [初始计划生成](#初始计划生成)
3. [当前步骤解析](#当前步骤解析)
4. [步骤执行准备](#步骤执行准备)
5. [步骤完成标记](#步骤完成标记)
6. [计划完成摘要](#计划完成摘要)
7. [错误处理与异常恢复](#错误处理与异常恢复)

## 执行主循环

`PlanningFlow`类的`execute`方法实现了任务执行的主循环，通过迭代执行计划中的各个步骤来完成整个任务。该方法首先检查是否存在主代理，然后根据输入请求创建初始计划。在主循环中，系统会持续获取当前待执行的步骤，调用相应的执行代理进行处理，直到所有步骤完成或代理主动终止。

主循环的核心逻辑包括：验证主代理的存在性、创建初始计划、循环获取并执行当前步骤、检查代理状态以决定是否终止。如果在执行过程中发生异常，系统会捕获异常并返回错误信息，确保流程的稳定性。

**Section sources**
- [planning.py](file://app/flow/planning.py#L93-L133)

## 初始计划生成

`_create_initial_plan`方法利用LLM和PlanningTool为输入请求生成初始计划。该方法首先构建系统消息，包含任务描述和可用代理的信息，然后创建用户消息，将输入请求传递给LLM。通过调用`llm.ask_tool`方法，系统可以利用PlanningTool生成计划。

当工具调用失败时，系统会创建一个默认计划作为备选方案。默认计划包含"分析请求"、"执行任务"和"验证结果"三个基本步骤，确保即使在LLM调用失败的情况下，系统仍能继续执行任务。这种方法提高了系统的鲁棒性，避免了因单点故障导致的流程中断。

**Section sources**
- [planning.py](file://app/flow/planning.py#L135-L210)

## 当前步骤解析

`_get_current_step_info`方法负责解析计划状态，找到第一个未完成的步骤，并自动将其状态标记为进行中。该方法首先检查计划是否存在，然后遍历步骤列表，查找状态为"未开始"或"进行中"的第一个步骤。

在找到目标步骤后，系统会尝试从步骤文本中提取类型信息（如[SEARCH]或[CODE]），以便选择合适的执行代理。同时，系统会调用PlanningTool将该步骤的状态更新为"进行中"，如果更新失败，则直接修改内存中的状态数据，确保状态同步。这种方法保证了计划执行的连续性和状态的一致性。

**Section sources**
- [planning.py](file://app/flow/planning.py#L212-L274)

## 步骤执行准备

`_execute_step`方法为执行代理准备上下文并调用其`run`方法执行当前步骤。该方法首先获取当前计划的文本表示，然后构建一个包含计划状态和当前任务的提示词，传递给选定的执行代理。

执行过程中，系统会捕获可能出现的异常，并返回相应的错误信息。如果步骤执行成功，系统会自动调用`_mark_step_completed`方法将该步骤标记为完成。这种方法实现了执行与状态管理的分离，提高了代码的模块化程度和可维护性。

**Section sources**
- [planning.py](file://app/flow/planning.py#L276-L303)

## 步骤完成标记

`_mark_step_completed`方法在步骤成功执行后更新计划状态。该方法通过调用PlanningTool的`mark_step`命令，将当前步骤的状态设置为"已完成"。如果调用失败，系统会直接修改内存中的计划数据，确保状态更新的可靠性。

状态更新包括：将步骤状态设置为"completed"、记录完成时间、更新计划的整体进度统计。这种方法实现了双重保障机制，既利用了工具的持久化能力，又保留了直接操作内存的备用方案，提高了系统的容错能力。

**Section sources**
- [planning.py](file://app/flow/planning.py#L305-L334)

## 计划完成摘要

`_finalize_plan`方法生成计划完成后的摘要信息。该方法首先获取最终的计划状态文本，然后利用流程的LLM生成总结报告。总结内容包括任务完成情况、关键成果和后续建议。

如果通过LLM生成总结失败，系统会退回到使用主代理生成总结的备用方案。这种多层次的容错机制确保了即使在LLM服务不可用的情况下，系统仍能提供基本的总结信息，保证了用户体验的连续性。

**Section sources**
- [planning.py](file://app/flow/planning.py#L405-L441)

## 错误处理与异常恢复

执行流程中的错误处理机制贯穿于各个方法中，确保系统在异常情况下的稳定运行。主要的异常处理策略包括：输入验证、状态检查、异常捕获和备用方案。

在异常恢复方面，系统采用了多层次的恢复策略：对于计划创建失败，使用默认计划；对于状态更新失败，直接操作内存数据；对于总结生成失败，切换到备用代理。这些策略共同构成了一个健壮的错误处理框架，提高了系统的可靠性和用户体验。

**Section sources**
- [planning.py](file://app/flow/planning.py#L93-L133)
- [planning.py](file://app/flow/planning.py#L405-L441)