# 任务分解与执行

<cite>
**本文档引用的文件**
- [planning.py](file://app/flow/planning.py)
- [planning.py](file://app/tool/planning.py)
- [planning.py](file://app/prompt/planning.py)
</cite>

## 目录
1. [任务计划生成](#任务计划生成)
2. [计划解析与状态追踪](#计划解析与状态追踪)
3. [分步执行机制](#分步执行机制)
4. [任务状态生命周期](#任务状态生命周期)
5. [计划失败恢复与默认策略](#计划失败恢复与默认策略)
6. [执行上下文记录](#执行上下文记录)
7. [中断恢复与人工干预](#中断恢复与人工干预)

## 任务计划生成

`PlanningFlow` 类通过 `_create_initial_plan` 方法调用 LLM 与 `PlanningTool` 生成结构化任务计划。该方法首先构建系统消息，包含任务要求和可用执行代理的描述，然后创建用户消息，请求 LLM 为指定任务创建合理计划。系统通过 `llm.ask_tool` 方法调用 LLM，并提供 `PlanningTool` 作为可用工具，允许 LLM 通过工具调用来创建计划。当 LLM 返回工具调用时，系统会解析参数并执行 `planning` 工具的 `create` 命令来创建计划。如果 LLM 未能成功创建计划，系统会作为后备机制，使用默认步骤（分析请求、执行任务、验证结果）创建一个默认计划。

**Section sources**
- [planning.py](file://app/flow/planning.py#L135-L210)

## 计划解析与状态追踪

`_get_current_step_info` 方法负责解析当前计划并追踪任务状态。该方法首先检查活动计划是否存在，然后直接从 `planning_tool` 的存储中获取计划数据。它遍历计划中的所有步骤，查找第一个状态为 `NOT_STARTED` 或 `IN_PROGRESS` 的步骤。在找到活动步骤后，方法会尝试使用正则表达式从步骤文本中提取类型信息（例如 `[SEARCH]` 或 `[CODE]`），并将该步骤的状态标记为 `IN_PROGRESS`。此状态更新通过调用 `planning_tool` 的 `mark_step` 命令完成。该方法返回当前步骤的索引和信息字典，为后续执行提供上下文。

**Section sources**
- [planning.py](file://app/flow/planning.py#L212-L274)

## 分步执行机制

`_execute_step` 方法实现了任务的分步执行闭环流程。该方法首先调用 `_get_plan_text` 获取当前计划的格式化文本，然后为执行代理构建一个包含当前计划状态和具体任务的提示。提示中明确指示代理仅执行当前步骤。代理通过其 `run` 方法执行该步骤，完成后，`_execute_step` 方法会调用 `_mark_step_completed` 将该步骤标记为完成。整个执行流程由 `execute` 方法中的主循环驱动，该循环持续调用 `_get_current_step_info` 获取下一步，然后调用 `_execute_step` 执行，直到所有步骤完成或代理请求终止。

**Section sources**
- [planning.py](file://app/flow/planning.py#L276-L303)

## 任务状态生命周期

`PlanStepStatus` 枚举定义了任务生命周期中的四种状态：`NOT_STARTED`（未开始）、`IN_PROGRESS`（进行中）、`COMPLETED`（已完成）和 `BLOCKED`（受阻）。这些状态的转换逻辑如下：当计划创建时，所有步骤初始化为 `NOT_STARTED`；当 `_get_current_step_info` 开始处理一个步骤时，其状态变为 `IN_PROGRESS`；当 `_execute_step` 成功完成一个步骤时，其状态变为 `COMPLETED`；如果一个步骤因依赖问题无法进行，其状态可被手动或通过逻辑设置为 `BLOCKED`。`get_active_statuses` 类方法返回 `NOT_STARTED` 和 `IN_PROGRESS`，用于识别需要处理的活动步骤。

**Section sources**
- [planning.py](file://app/flow/planning.py#L15-L41)

## 计划失败恢复与默认策略

系统包含完善的计划失败恢复机制和默认计划生成策略。在 `_create_initial_plan` 方法中，如果 LLM 调用未能成功创建计划（例如，未返回工具调用或解析失败），系统会捕获异常并执行后备逻辑，通过 `planning_tool.execute` 直接创建一个包含默认步骤（“分析请求”、“执行任务”、“验证结果”）的计划。此外，在 `_get_plan_text` 和 `_mark_step_completed` 等关键方法中也实现了容错机制。如果通过工具调用获取计划文本失败，系统会调用 `_generate_plan_text_from_storage` 直接从 `planning_tool` 的内部存储中生成计划文本。同样，如果更新步骤状态的工具调用失败，系统会直接在内存中的计划数据结构上更新状态，确保流程不会因单个操作失败而中断。

**Section sources**
- [planning.py](file://app/flow/planning.py#L135-L210)
- [planning.py](file://app/flow/planning.py#L336-L345)
- [planning.py](file://app/flow/planning.py#L305-L334)

## 执行上下文记录

系统通过 `_step_notes` 设计来记录执行上下文。`PlanningTool` 在其内部数据结构中为每个计划的每个步骤维护一个 `step_notes` 列表，初始为空字符串。当调用 `mark_step` 命令时，可以传递一个 `step_notes` 参数，该参数的值将被存储在对应步骤的 `step_notes` 字段中。这些笔记随后会被 `_format_plan` 方法包含在格式化的计划输出中，显示在相应的步骤下方。这使得用户和代理能够查看每个步骤的附加信息、执行摘要或遇到的问题，为任务执行提供了丰富的上下文历史。

**Section sources**
- [planning.py](file://app/tool/planning.py#L68-L69)
- [planning.py](file://app/tool/planning.py#L256-L303)
- [planning.py](file://app/tool/planning.py#L321-L362)

## 中断恢复与人工干预

系统提供了任务中断恢复和人工干预的接口。`PlanningTool` 提供了 `list`、`get`、`set_active` 和 `mark_step` 等命令，允许外部查询和修改计划状态。用户或管理员可以通过调用 `list` 命令查看所有可用计划及其进度，使用 `get` 命令获取特定计划的详细信息，并通过 `set_active` 命令切换活动计划。最关键的是，`mark_step` 命令允许人工直接修改任何步骤的状态（例如，将一个 `BLOCKED` 步骤重新标记为 `IN_PROGRESS`）或添加 `step_notes`。这使得在自动化流程因意外情况中断时，操作员可以介入，调整计划状态，从而恢复任务执行。

**Section sources**
- [planning.py](file://app/tool/planning.py#L208-L241)
- [planning.py](file://app/tool/planning.py#L243-L254)
- [planning.py](file://app/tool/planning.py#L256-L303)