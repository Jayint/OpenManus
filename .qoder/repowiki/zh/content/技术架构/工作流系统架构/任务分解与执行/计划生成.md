# 计划生成

<cite>
**Referenced Files in This Document**  
- [planning.py](file://app/flow/planning.py)
- [planning.py](file://app/tool/planning.py)
- [planning.py](file://app/prompt/planning.py)
- [base.py](file://app/flow/base.py)
- [llm.py](file://app/llm.py)
- [schema.py](file://app/schema.py)
</cite>

## 目录
1. [计划生成流程概述](#计划生成流程概述)
2. [核心组件分析](#核心组件分析)
3. [_create_initial_plan方法详解](#_create_initial_plan方法详解)
4. [系统提示词设计](#系统提示词设计)
5. [多代理协作与任务分配](#多代理协作与任务分配)
6. [LLM响应解析流程](#llm响应解析流程)
7. [默认计划生成策略](#默认计划生成策略)
8. [请求到计划的完整链路](#请求到计划的完整链路)
9. [plan_id生成规则与生命周期](#plan_id生成规则与生命周期)

## 计划生成流程概述

PlanningFlow系统通过结构化流程将用户请求转化为可执行的任务计划。该流程始于用户输入，经过LLM与PlanningTool的协同工作，最终生成包含明确步骤的行动计划。系统设计了完整的错误处理机制，在LLM调用失败时能够生成默认计划，确保流程的鲁棒性。

**Section sources**
- [planning.py](file://app/flow/planning.py#L135-L210)

## 核心组件分析

系统由多个核心组件构成，包括PlanningFlow、PlanningTool、LLM等，它们协同工作实现计划生成功能。

```mermaid
classDiagram
class PlanningFlow {
+llm : LLM
+planning_tool : PlanningTool
+executor_keys : List[str]
+active_plan_id : str
+current_step_index : Optional[int]
+__init__(agents, **data)
+get_executor(step_type) BaseAgent
+execute(input_text) str
+_create_initial_plan(request) None
+_get_current_step_info() tuple[Optional[int], Optional[dict]]
+_execute_step(executor, step_info) str
+_mark_step_completed() None
+_get_plan_text() str
+_generate_plan_text_from_storage() str
+_finalize_plan() str
}
class PlanningTool {
+name : str
+description : str
+parameters : dict
+plans : dict
+_current_plan_id : Optional[str]
+execute(command, plan_id, title, steps, step_index, step_status, step_notes) ToolResult
+_create_plan(plan_id, title, steps) ToolResult
+_update_plan(plan_id, title, steps) ToolResult
+_list_plans() ToolResult
+_get_plan(plan_id) ToolResult
+_set_active_plan(plan_id) ToolResult
+_mark_step(plan_id, step_index, step_status, step_notes) ToolResult
+_delete_plan(plan_id) ToolResult
+_format_plan(plan) str
}
class LLM {
+_instances : Dict[str, LLM]
+model : str
+max_tokens : int
+temperature : int
+api_type : str
+api_key : str
+api_version : str
+base_url : str
+total_input_tokens : int
+total_completion_tokens : int
+max_input_tokens : Optional[int]
+tokenizer : Encoding
+client : Union[AsyncAzureOpenAI, AsyncOpenAI, BedrockClient]
+token_counter : TokenCounter
+__new__(config_name, llm_config) LLM
+__init__(config_name, llm_config) None
+count_tokens(text) int
+count_message_tokens(messages) int
+update_token_count(input_tokens, completion_tokens) None
+check_token_limit(input_tokens) bool
+get_limit_error_message(input_tokens) str
+format_messages(messages, supports_images) List[dict]
+ask(messages, system_msgs, stream, temperature) str
+ask_with_images(messages, images, system_msgs, stream, temperature) str
+ask_tool(messages, system_msgs, timeout, tools, tool_choice, temperature, **kwargs) ChatCompletionMessage
}
class BaseFlow {
+agents : Dict[str, BaseAgent]
+tools : Optional[List]
+primary_agent_key : Optional[str]
+__init__(agents, **data) None
+primary_agent() Optional[BaseAgent]
+get_agent(key) Optional[BaseAgent]
+add_agent(key, agent) None
+execute(input_text) str
}
class Message {
+role : ROLE_TYPE
+content : Optional[str]
+tool_calls : Optional[List[ToolCall]]
+name : Optional[str]
+tool_call_id : Optional[str]
+base64_image : Optional[str]
+__add__(other) List[Message]
+__radd__(other) List[Message]
+to_dict() dict
+user_message(content, base64_image) Message
+system_message(content) Message
+assistant_message(content, base64_image) Message
+tool_message(content, name, tool_call_id, base64_image) Message
+from_tool_calls(tool_calls, content, base64_image, **kwargs) Message
}
class ToolChoice {
+NONE : str
+AUTO : str
+REQUIRED : str
}
PlanningFlow --> BaseFlow : "继承"
PlanningFlow --> LLM : "使用"
PlanningFlow --> PlanningTool : "使用"
PlanningFlow --> Message : "使用"
PlanningTool --> BaseTool : "继承"
LLM --> TokenCounter : "使用"
Message --> BaseModel : "继承"
ToolChoice --> Enum : "继承"
```

**Diagram sources**
- [planning.py](file://app/flow/planning.py#L44-L441)
- [planning.py](file://app/tool/planning.py#L13-L362)
- [llm.py](file://app/llm.py#L173-L765)
- [base.py](file://app/flow/base.py#L8-L56)
- [schema.py](file://app/schema.py#L53-L155)
- [schema.py](file://app/schema.py#L19-L24)

**Section sources**
- [planning.py](file://app/flow/planning.py#L44-L441)
- [planning.py](file://app/tool/planning.py#L13-L362)
- [llm.py](file://app/llm.py#L173-L765)

## _create_initial_plan方法详解

`_create_initial_plan`方法是计划生成的核心，它协调LLM和PlanningTool创建初始计划。该方法首先构建系统消息，包含代理描述信息，然后创建用户消息，调用LLM的`ask_tool`方法，最后处理响应并执行计划创建。

```mermaid
sequenceDiagram
participant PF as PlanningFlow
participant LLM as LLM
participant PT as PlanningTool
participant Response as LLM响应
PF->>PF : 构建系统消息
PF->>PF : 添加代理描述
PF->>PF : 创建用户消息
PF->>LLM : 调用ask_tool
LLM->>LLM : 处理工具调用
LLM-->>PF : 返回响应
PF->>PF : 检查tool_calls
alt 存在tool_calls
PF->>PF : 解析参数
PF->>PF : 设置plan_id
PF->>PT : 执行planning工具
PT-->>PF : 返回结果
else 无tool_calls
PF->>PT : 创建默认计划
PT-->>PF : 返回默认计划
end
```

**Diagram sources**
- [planning.py](file://app/flow/planning.py#L135-L210)

**Section sources**
- [planning.py](file://app/flow/planning.py#L135-L210)

## 系统提示词设计

系统提示词设计旨在引导LLM创建简洁、可操作的计划。提示词强调关键里程碑而非详细子步骤，优化清晰度和效率。当存在多个代理时，系统会动态添加代理描述信息，指导LLM在创建步骤时指定代理名称。

```python
system_message_content = (
    "You are a planning assistant. Create a concise, actionable plan with clear steps. "
    "Focus on key milestones rather than detailed sub-steps. "
    "Optimize for clarity and efficiency."
)
```

当存在多个代理时，系统会追加以下信息：

```python
system_message_content += (
    f"\nNow we have {agents_description} agents. "
    f"The infomation of them are below: {json.dumps(agents_description)}\n"
    "When creating steps in the planning tool, please specify the agent names using the format '[agent_name]'."
)
```

**Section sources**
- [planning.py](file://app/flow/planning.py#L138-L157)

## 多代理协作与任务分配

系统支持多代理协作场景，通过`executor_keys`管理可用的执行代理。在创建计划时，系统会收集所有代理的描述信息，并将其包含在系统提示中，指导LLM在计划步骤中指定适当的代理。

代理选择机制通过`get_executor`方法实现，该方法根据步骤类型选择合适的执行代理：

```python
def get_executor(self, step_type: Optional[str] = None) -> BaseAgent:
    """
    获取当前步骤的适当执行代理。
    可以根据步骤类型/需求扩展以选择代理。
    """
    # 如果提供了步骤类型且与代理键匹配，则使用该代理
    if step_type and step_type in self.agents:
        return self.agents[step_type]

    # 否则使用第一个可用的执行器或回退到主代理
    for key in self.executor_keys:
        if key in self.agents:
            return self.agents[key]

    # 回退到主代理
    return self.primary_agent
```

**Section sources**
- [planning.py](file://app/flow/planning.py#L65-L84)

## LLM响应解析流程

LLM响应解析流程包括多个步骤：首先检查响应中是否存在`tool_calls`，然后遍历所有工具调用，识别名为"planning"的调用，解析其参数，设置正确的`plan_id`，最后通过`planning_tool.execute`执行计划创建。

```mermaid
flowchart TD
Start([开始解析LLM响应]) --> CheckToolCalls{"存在tool_calls?"}
CheckToolCalls --> |是| LoopStart[开始遍历tool_calls]
LoopStart --> GetCall[获取当前tool_call]
GetCall --> CheckName{"函数名为planning?"}
CheckName --> |是| ParseArgs[解析参数]
ParseArgs --> SetPlanId[设置plan_id]
SetPlanId --> ExecuteTool[执行planning_tool]
ExecuteTool --> Return[返回结果]
CheckName --> |否| NextCall[下一个调用]
NextCall --> CheckMore{"还有更多调用?"}
CheckMore --> |是| LoopStart
CheckMore --> |否| CreateDefault[创建默认计划]
CheckToolCalls --> |否| CreateDefault
CreateDefault --> End([结束])
```

**Diagram sources**
- [planning.py](file://app/flow/planning.py#L175-L210)

**Section sources**
- [planning.py](file://app/flow/planning.py#L175-L210)

## 默认计划生成策略

当LLM调用失败或未返回有效的工具调用时，系统会生成默认计划作为后备策略。默认计划包含三个通用步骤：'Analyze request'、'Execute task'、'Verify results'，确保即使在失败情况下也能继续执行。

```python
# 如果执行到达此处，创建默认计划
logger.warning("Creating default plan")

# 使用ToolCollection创建默认计划
await self.planning_tool.execute(
    **{
        "command": "create",
        "plan_id": self.active_plan_id,
        "title": f"Plan for: {request[:50]}{'...' if len(request) > 50 else ''}",
        "steps": ["Analyze request", "Execute task", "Verify results"],
    }
)
```

这些步骤的构造逻辑如下：
- **Analyze request**: 分析请求，理解任务范围和需求
- **Execute task**: 执行主要任务，使用适当的工具
- **Verify results**: 验证结果，确保任务完成质量

**Section sources**
- [planning.py](file://app/flow/planning.py#L198-L210)

## 请求到计划的完整链路

从用户请求到计划创建的完整链路涉及多个组件的协同工作。用户请求首先传递给`execute`方法，该方法调用`_create_initial_plan`来创建初始计划。

```mermaid
sequenceDiagram
participant User as 用户
participant PF as PlanningFlow
participant LLM as LLM
participant PT as PlanningTool
User->>PF : execute(input_text)
PF->>PF : _create_initial_plan(input_text)
PF->>PF : 构建系统消息
PF->>PF : 构建用户消息
PF->>LLM : ask_tool(messages, system_msgs, tools)
LLM->>LLM : 处理请求
LLM-->>PF : 返回响应
PF->>PF : 解析tool_calls
alt 成功解析
PF->>PT : execute(create, plan_id, title, steps)
PT-->>PF : 返回创建结果
PF-->>User : 返回执行结果
else 解析失败
PF->>PT : execute(create默认计划)
PT-->>PF : 返回默认计划
PF-->>User : 返回执行结果
end
```

**Diagram sources**
- [planning.py](file://app/flow/planning.py#L86-L133)
- [planning.py](file://app/flow/planning.py#L135-L210)

**Section sources**
- [planning.py](file://app/flow/planning.py#L86-L133)

## plan_id生成规则与生命周期

`plan_id`的生成规则和生命周期管理是计划系统的重要组成部分。`plan_id`在`PlanningFlow`初始化时通过时间戳生成，确保唯一性。

```python
active_plan_id: str = Field(default_factory=lambda: f"plan_{int(time.time())}")
```

`plan_id`的生命周期包括以下阶段：
1. **生成**: 在`PlanningFlow`初始化时生成
2. **使用**: 在创建计划时作为`plan_id`参数传递
3. **存储**: 在`PlanningTool.plans`字典中以`plan_id`为键存储计划
4. **激活**: 创建计划时自动设置为当前活动计划
5. **删除**: 通过`delete`命令从存储中移除

`plan_id`的生成规则确保了每个计划都有唯一的标识符，便于跟踪和管理。时间戳基础的生成方式简单有效，避免了ID冲突的可能性。

**Section sources**
- [planning.py](file://app/flow/planning.py#L47-L48)
- [planning.py](file://app/tool/planning.py#L13-L362)