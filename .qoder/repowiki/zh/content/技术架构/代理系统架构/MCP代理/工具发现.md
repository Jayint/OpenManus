# 工具发现

<cite>
**本文档引用的文件**
- [mcp.py](file://app/tool/mcp.py)
- [server.py](file://app/mcp/server.py)
- [tool_collection.py](file://app/tool/tool_collection.py)
- [mcp.py](file://app/agent/mcp.py)
- [manus.py](file://app/agent/manus.py)
</cite>

## 目录
1. [引言](#引言)
2. [核心组件](#核心组件)
3. [工具发现机制](#工具发现机制)
4. [工具注册与映射](#工具注册与映射)
5. [会话初始化与原子性保证](#会话初始化与原子性保证)
6. [多服务器环境下的命名冲突解决方案](#多服务器环境下的命名冲突解决方案)
7. [工具元数据映射机制](#工具元数据映射机制)
8. [动态工具管理](#动态工具管理)
9. [结论](#结论)

## 引言
OpenManus MCP工具发现机制为系统提供了动态集成远程工具的能力。该机制允许MCPClients通过list_tools接口实现动态工具发现，将远程MCP服务器的工具无缝集成到本地工具调用系统中。本技术文档详细阐述了工具发现、注册、映射和管理的完整流程，重点说明了工具名称标准化处理、服务器隔离策略以及多服务器环境下的命名冲突解决方案。

## 核心组件

OpenManus MCP工具发现机制由多个核心组件构成，这些组件协同工作以实现动态工具发现和管理功能。

### MCPClients类
MCPClients类是工具发现机制的核心，继承自ToolCollection，负责管理与多个MCP服务器的连接和工具注册。

**Section sources**
- [mcp.py](file://app/tool/mcp.py#L36-L193)

### MCPClientTool类
MCPClientTool类代表一个可以代理调用的远程工具，封装了远程工具的执行逻辑。

**Section sources**
- [mcp.py](file://app/tool/mcp.py#L13-L33)

### ToolCollection类
ToolCollection类是工具集合的基础类，提供了工具管理的基本功能。

**Section sources**
- [tool_collection.py](file://app/tool/tool_collection.py#L8-L70)

## 工具发现机制

OpenManus MCP工具发现机制通过list_tools接口实现动态工具发现，允许客户端连接到MCP服务器并获取可用工具列表。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant MCPClients as "MCPClients"
participant Server as "MCP服务器"
Client->>MCPClients : connect_sse/connect_stdio
MCPClients->>Server : 建立连接(SSE/stdio)
MCPClients->>MCPClients : _initialize_and_list_tools
MCPClients->>Server : session.initialize()
MCPClients->>Server : session.list_tools()
Server-->>MCPClients : 返回工具列表
MCPClients->>MCPClients : 处理工具并注册
MCPClients-->>Client : 连接完成
```

**Diagram sources**
- [mcp.py](file://app/tool/mcp.py#L49-L94)
- [mcp.py](file://app/tool/mcp.py#L96-L125)

**Section sources**
- [mcp.py](file://app/tool/mcp.py#L49-L94)

## 工具注册与映射

工具注册与映射过程是MCP工具发现机制的关键环节，确保远程工具能够被正确识别和调用。

### _tool_map中的工具注册
MCPClients通过_tool_map字典管理所有发现的工具，每个工具在注册时都会经过一系列处理步骤。

#### 工具注册流程
```mermaid
flowchart TD
Start([开始工具注册]) --> GetToolInfo["获取工具信息\n(名称、描述、参数schema)"]
GetToolInfo --> GenerateName["生成工具名称\nmcp_{server_id}_{original_name}"]
GenerateName --> SanitizeName["标准化工具名称\n_sanitize_tool_name"]
SanitizeName --> CreateTool["创建MCPClientTool实例"]
CreateTool --> RegisterTool["注册到_tool_map"]
RegisterTool --> UpdateTools["更新tools元组"]
UpdateTools --> End([工具注册完成])
```

**Diagram sources**
- [mcp.py](file://app/tool/mcp.py#L102-L125)

### 工具名称标准化处理
工具名称标准化处理通过_sanitize_tool_name方法实现，确保工具名称符合系统要求。

#### 标准化处理规则
```mermaid
flowchart TD
Start([输入原始名称]) --> ReplaceInvalid["替换无效字符\n[^a-zA-Z0-9_-] → _"]
ReplaceInvalid --> RemoveConsecutive["移除连续下划线\n_+ → _"]
RemoveConsecutive --> StripUnderscore["去除首尾下划线\nstrip('_')"]
StripUnderscore --> TruncateName["截断名称\n>64字符"]
TruncateName --> ReturnResult["返回标准化名称"]
```

**Diagram sources**
- [mcp.py](file://app/tool/mcp.py#L127-L144)

**Section sources**
- [mcp.py](file://app/tool/mcp.py#L127-L144)

## 会话初始化与原子性保证

_initialize_and_list_tools方法确保了会话初始化与工具注册的原子性，保证了操作的完整性和一致性。

### 原子性保证机制
```mermaid
sequenceDiagram
participant MCPClients as "MCPClients"
participant Session as "ClientSession"
MCPClients->>MCPClients : _initialize_and_list_tools(server_id)
MCPClients->>Session : session.initialize()
Session-->>MCPClients : 初始化完成
MCPClients->>Session : session.list_tools()
Session-->>MCPClients : 返回工具列表
MCPClients->>MCPClients : 遍历工具列表
loop 每个工具
MCPClients->>MCPClients : 生成标准化名称
MCPClients->>MCPClients : 创建MCPClientTool
MCPClients->>MCPClients : 注册到_tool_map
end
MCPClients->>MCPClients : 更新tools元组
MCPClients-->>MCPClients : 操作完成
```

**Diagram sources**
- [mcp.py](file://app/tool/mcp.py#L96-L125)

**Section sources**
- [mcp.py](file://app/tool/mcp.py#L96-L125)

## 多服务器环境下的命名冲突解决方案

在多服务器环境下，OpenManus通过服务器隔离策略有效解决了工具命名冲突问题。

### 服务器隔离策略
```mermaid
classDiagram
class MCPClients {
+sessions : Dict[str, ClientSession]
+exit_stacks : Dict[str, AsyncExitStack]
+tool_map : Dict[str, MCPClientTool]
+tools : Tuple[MCPClientTool]
+connect_sse()
+connect_stdio()
+_initialize_and_list_tools()
+_sanitize_tool_name()
+disconnect()
}
class MCPClientTool {
+name : str
+description : str
+parameters : dict
+session : ClientSession
+server_id : str
+original_name : str
+execute()
}
class ClientSession {
+initialize()
+list_tools()
+call_tool()
}
MCPClients --> "1..*" MCPClientTool : 包含
MCPClients --> "1..*" ClientSession : 管理
MCPClientTool --> ClientSession : 调用
```

**Diagram sources**
- [mcp.py](file://app/tool/mcp.py#L36-L193)
- [mcp.py](file://app/tool/mcp.py#L13-L33)

### 命名冲突解决方案
系统通过以下策略解决多服务器环境下的命名冲突：

1. **前缀隔离**: 为每个工具名称添加`mcp_{server_id}_`前缀
2. **服务器ID标识**: 在MCPClientTool中保留server_id字段用于标识来源服务器
3. **原始名称保留**: 保留original_name字段用于远程调用
4. **连接管理**: 通过sessions字典管理不同服务器的连接

当连接到多个服务器时，即使它们有同名工具，也会被注册为不同的本地工具名称，避免了命名冲突。

**Section sources**
- [mcp.py](file://app/tool/mcp.py#L102-L125)
- [mcp.py](file://app/tool/mcp.py#L36-L43)

## 工具元数据映射机制

工具元数据映射机制确保了远程工具的描述信息和参数schema能够正确映射到本地工具系统。

### 元数据映射流程
```mermaid
flowchart TD
Start([远程工具元数据]) --> NameMapping["名称映射\noriginal_name → name"]
NameMapping --> DescriptionMapping["描述映射\ndescription"]
DescriptionMapping --> ParametersMapping["参数schema映射\ninputSchema → parameters"]
ParametersMapping --> SessionMapping["会话映射\nsession"]
SessionMapping --> ServerIdMapping["服务器ID映射\nserver_id"]
ServerIdMapping --> Complete["完成元数据映射"]
```

**Diagram sources**
- [mcp.py](file://app/tool/mcp.py#L102-L125)

### 元数据字段说明
| 字段名称 | 来源 | 用途 | 是否保留原始值 |
|--------|------|------|-------------|
| name | 标准化处理后 | 本地调用标识 | 否 |
| original_name | 远程工具 | 远程调用标识 | 是 |
| description | 远程工具 | 工具描述 | 是 |
| parameters | 远程工具inputSchema | 参数定义 | 是 |
| server_id | 连接参数 | 服务器标识 | 是 |
| session | ClientSession | 远程调用会话 | 是 |

**Section sources**
- [mcp.py](file://app/tool/mcp.py#L102-L125)

## 动态工具管理

OpenManus提供了完整的动态工具管理功能，支持工具的连接、断开和刷新。

### 连接管理
MCPClients支持两种连接方式：
- **SSE连接**: 通过connect_sse方法使用SSE传输
- **stdio连接**: 通过connect_stdio方法使用stdio传输

两种连接方式都遵循相同的处理流程：先确保清理现有连接，然后建立新连接，最后初始化并列出工具。

### 断开连接
disconnect方法支持断开特定服务器或所有服务器的连接，同时清理相关资源和工具注册。

```mermaid
flowchart TD
Start([断开连接]) --> CheckServer["检查server_id"]
CheckServer --> |特定服务器| DisconnectSpecific["断开特定服务器"]
CheckServer --> |所有服务器| DisconnectAll["断开所有服务器"]
DisconnectSpecific --> CloseExitStack["关闭ExitStack"]
DisconnectAll --> SortServers["排序服务器ID"]
SortServers --> LoopServers["循环断开每个服务器"]
LoopServers --> CloseExitStack
CloseExitStack --> CleanupReferences["清理sessions和exit_stacks"]
CleanupReferences --> RemoveTools["从_tool_map移除相关工具"]
RemoveTools --> UpdateTools["更新tools元组"]
UpdateTools --> End([断开完成])
```

**Diagram sources**
- [mcp.py](file://app/tool/mcp.py#L146-L193)

**Section sources**
- [mcp.py](file://app/tool/mcp.py#L146-L193)

## 结论
OpenManus MCP工具发现机制通过精心设计的架构实现了远程工具的动态发现和管理。该机制的核心优势包括：

1. **动态发现**: 通过list_tools接口实现工具的动态发现
2. **名称标准化**: 通过_sanitize_tool_name方法确保工具名称的合规性
3. **服务器隔离**: 通过前缀和server_id实现多服务器环境下的命名冲突解决
4. **原子性保证**: _initialize_and_list_tools方法确保会话初始化和工具注册的原子性
5. **无缝集成**: 将远程MCP工具无缝集成到本地工具调用系统

这一机制为OpenManus系统提供了强大的扩展能力，使其能够灵活地集成各种远程工具服务，同时保持系统的稳定性和可靠性。